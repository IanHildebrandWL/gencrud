#
#   Python backend and Angular frontend code generation by gencrud
#   Copyright (C) 2018 Marc Bertens-Nguyen m.bertens@pe2mbs.nl
#
#   This library is free software; you can redistribute it and/or modify
#   it under the terms of the GNU Library General Public License GPL-2.0-only
#   as published by the Free Software Foundation; either version 2 of the
#   License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#   Library General Public License for more details.
#
#   You should have received a copy of the GNU Library General Public
#   License GPL-2.0-only along with this library; if not, write to the
#   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
#   Boston, MA 02110-1301 USA
#
#   Frontend view for the ${ obj.name } table, this is generated by the
#   gencrud.py module. When modifing the file make sure that you remove
#   the table from the configuration.
#
import logging
from pytemplate.objects.table._inports import SourceImport
from pytemplate.objects.table.column import TemplateColumn
from pytemplate.objects.table.column.tab import TemplateTabs
import pytemplate.util.utils

logger = logging.getLogger()


class SortInfo( object ):
    def __init__( self, data ):
        self.__field    = data[ 'field' ]

        # 'asc'
        # 'desc'
        # ''
        if data[ 'order' ] in ( 'asc', 'desc', '' ):
            self.__order    = data[ 'order' ]

        else:
            raise Exception( "Sorting order must be one of the following: 'asc', 'desc' or ''")

        return

    @property
    def Field( self ):
        return self.__field

    @property
    def Order( self ):
        return self.__order

    def injectAngular( self ):
        return self.AngularInject()

    def AngularInject( self ):
        return "this.sort.sort( {{ id: '{field}', start: '{order}' }} as MatSortable );".format( field = self.__field,
                                                                                                 order = self.__order )

class PythonObject( object ):
    def __init__( self, obj ):
        self.__object   = obj
        self.__module   = None
        self.__class    = None
        if obj is not None and '.' in obj:
            self.__module, self.__class = obj.rsplit( '.', 1 )

        return

    @property
    def Available( self ):
        return self.__object is not None

    @property
    def Class( self ):
        return self.__class

    @property
    def Module( self ):
        return self.__module


class TemplateMixin( object ):
    def __init__( self, mixin ):
        self.__model    = PythonObject( mixin[ 'model' ] if mixin is not None and 'model' in mixin else None )
        self.__schema   = PythonObject( mixin[ 'schema' ] if mixin is not None and 'schema' in mixin else None )
        self.__view     = PythonObject( mixin[ 'view' ] if mixin is not None and 'view' in mixin else None )
        return

    @property
    def Model( self ):
        return self.__model

    @property
    def Schema( self ):
        return self.__schema

    @property
    def View( self ):
        return self.__view


class TemplateTable( object ):
    def __init__( self, **table ):
        self.__table            = table
        self.__columns          = []
        self.__primaryKey       = ''
        self.__viewSort         = None
        self.__viewSize         = None
        self.__defaultViewSize  = 10
        self.__inports          = SourceImport()
        noColumns               = len( self.__table[ 'columns' ] )
        for col in self.__table[ 'columns' ]:
            column = TemplateColumn( noColumns,
                                     self.name,
                                     **col )
            self.__columns.append( column )
            if column.isPrimaryKey():
                self.__primaryKey = column.name

        if 'viewSort' in table:
            self.__viewSort = SortInfo( table[ 'viewSort' ] )

        if 'viewSize' in table:
            if type( table[ 'viewSize' ] ) in ( int, str ):
                self.__viewSize = table[ 'viewSize' ]

            else:
                raise Exception( "Invalid parameter 'viewSize', may be integer (5, 10, 25, 100) or string with service class name of where the function getViewSize() resides." )

        self.__mixin = TemplateMixin( table[ 'mixin' ] if 'mixin' in table else None )

        if 'tsInport' in table:
            source = 'tsInport'

        elif 'pyInport' in table:
            source = 'pyInport'

        else:
            return

        self.__inports.append( source, table[ source ] )
        return

    def hasTabs( self, tp = 'dialog' ):
        return len( self.__table.get( tp + 'tabs', [] ) ) > 0

    def tabs( self, tp = 'dialog' ):
        return TemplateTabs( self, **self.__table.get( tp + 'tabs', {} ) )

    @property
    def Mixin( self ):
        return self.__mixin

    @property
    def leadIn( self ):
        result = []
        for column in self.__columns:
            for leadin in column.leadIn:
                if leadin not in result:
                    result.append( leadin )

        return '\n'.join( result )

    @property
    def tableName( self ):
        if pytemplate.util.utils.lowerCaseDbIds:
            return self.__table.get( 'name', '' ).lower()

        return self.__table.get( 'name', '' )

    @property
    def name( self ):
        if pytemplate.util.utils.lowerCaseDbIds:
            return self.__table.get( 'name', '' ).lower()

        return self.__table.get( 'name', '' )

    @property
    def orderBy( self ):
        return self.__table.get( 'order-by', [ self.__primaryKey ] )

    @property
    def uniqueKey( self ):
        values  = {}
        for value in self.__table.get( 'unique-key', {} ):
            for key in value.keys():
                values[ key ] = ', '.join( [ "'{0}'".format( x ) for x in value[ key ] ] )

        return values

    def hasUniqueKey( self ):
        if 'unique-key' in self.__table:
            if type( self.__table.get( 'unique-key', None ) ) in ( dict, tuple, list ):
                return True

        return False

    @property
    def hasAutoUpdate( self ):
        for field in self.__columns:
            if field.hasAutoUpdate:
                return True

        return False

    @property
    def columns( self ):
        return self.__columns

    @property
    def primaryKey( self ):
        return self.__primaryKey

    @property
    def tsInports( self ):
        return self.__inports.typescript

    @property
    def pyInports( self ):
        return self.__inports.python

    @property
    def listViewColumns( self ):
        return sorted( [ col for col in self.__columns if col.listview.index is not None ],
                       key = lambda col: col.listview.index )

    def buildFilter( self ):
        result = [ ]
        for item in self.listViewColumns:
            if item.ui.isChoice() or item.ui.isCombobox():
                result.append( "( this.{0}_Label( record.{0} ) )".format( item.name ) )

            elif item.ui.isCheckbox() or item.ui.isSliderToggle():
                result.append( "( this.{0}_Label( record.{0} ) )".format( item.name ) )

            elif item.tsType == 'string':
                result.append( "( record.{0} || '' )".format( item.name ) )

        if len( result ) == 0:
            return "''"

        return (' + \r\n                   '.join( result ))

    @property
    def viewSort( self ):
        return self.__viewSort

    @property
    def hasViewSizeService( self ):
        if self.__viewSize is not None:
            return type( self.__viewSize ) is str

        return False

    @property
    def hasViewSizeValue( self ):
        if self.__viewSize is not None:
            return type( self.__viewSize ) is int

        return False

    @property
    def viewSize( self ):
        return self.__viewSize
