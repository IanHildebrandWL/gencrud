#
#   Python backend and Angular frontend code generation by Template
#   Copyright (C) 2018 Marc Bertens-Nguyen m.bertens@pe2mbs.nl
#
#   This library is free software; you can redistribute it and/or modify
#   it under the terms of the GNU Library General Public License as
#   published by the Free Software Foundation; either version 2 of the
#   License, or (at your option) any later version.
#
#   This library is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#   Library General Public License for more details.
#
#   You should have received a copy of the GNU Library General Public
#   License along with this library; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#   MA 02110-1301 USA
#
#   Backend view for the ${obj.name} table, this is generated by the
#   gencrud.py module. When modifing the file make sure that you remove
#   the table from the configuration.
#
import logging
import datetime
from flask import Blueprint, request, jsonify
from applic.database import db
from ${ obj.application }.${ obj.name }.model import ${ obj.cls }
from ${ obj.application }.${ obj.name }.schema import ${ obj.name }Schema, ${ obj.name }sSchema
import sqlalchemy.sql.sqltypes

${ obj.name }Api = Blueprint( '${ obj.name }Api', __name__ )

logger = logging.getLogger()


def registerApi( app, cors ):
    # Set the logger for the users module
    if app.config.get( 'ALLOW_CORS_ORIGIN', False ):
        app.logger.info( 'Allowing CORS' )
        if app.config.get( 'ALLOW_CORS_ORIGIN', False ):
            origins = app.config.get( 'CORS_ORIGIN_WHITELIST', '*' )
            cors.init_app( '${ obj.name }Api', origins = origins )

    logger.info( 'Register ${ obj.cls } routes' )
    app.register_blueprint( ${ obj.name }Api )
    return


def fieldConversion( record, key, value, default = None ):
    _type = record.__table__.columns[key].type
    logger.debug( 'field {0} value {1} type {2}'.format( key, value, _type ) )

    if isinstance( _type, ( sqlalchemy.sql.sqltypes.Integer,
                            sqlalchemy.sql.sqltypes.INTEGER,
                            sqlalchemy.sql.sqltypes.BigInteger,
                            sqlalchemy.sql.sqltypes.INT,
                            sqlalchemy.sql.sqltypes.BIGINT ) ):
        if value is not None:
            value = int( str( value ) )

        elif default is not None:
            value = default

    elif isinstance( _type, ( sqlalchemy.sql.sqltypes.REAL,
                              sqlalchemy.sql.sqltypes.Float,
                              sqlalchemy.sql.sqltypes.FLOAT,
                              sqlalchemy.sql.sqltypes.DECIMAL,
                              sqlalchemy.sql.sqltypes.Numeric,
                              sqlalchemy.sql.sqltypes.NUMERIC ) ):
        if value is not None:
            value = float( str( value ) )

        elif default is not None:
            value = default

    elif isinstance( _type, ( sqlalchemy.sql.sqltypes.DateTime,
                              sqlalchemy.sql.sqltypes.DATETIME,
                              sqlalchemy.sql.sqltypes.TIMESTAMP ) ):
        if value is not None:
            value = value[0:22] + value[23:]
            logger.debug( 'datetime.datetime.value: {}'.format( value ) )
            value = datetime.datetime.strptime( value, '%Y-%m-%dT%H:%M:%S%z' )

        elif default is not None:
            value = default

    elif isinstance( _type, ( sqlalchemy.sql.sqltypes.Date,
                              sqlalchemy.sql.sqltypes.DATE ) ):
        # TODO: needs to be tested
        if value is not None:
            value = datetime.datetime.strptime( value, '%Y-%m-%d' ).date()

        elif default is not None:
            value = default

    elif isinstance( _type, ( sqlalchemy.sql.sqltypes.Time,
                              sqlalchemy.sql.sqltypes.TIME ) ):
        # TODO: needs to be tested
        if value is not None:
            value = datetime.datetime.strptime( value, '%H:%M:%S' ).time()

        elif default is not None:
            value = default

    elif isinstance( _type, ( sqlalchemy.sql.sqltypes.Boolean,
                              sqlalchemy.sql.sqltypes.BOOLEAN ) ):
        if type( value ) is int:
            value = bool( value )

        elif type( value ) is str:
            value = bool( value )

        elif value is None:
            if default is not None:
                value = default

            else:
                value = False

    logger.debug( 'field {0} value {1}'.format( key, value ) )
    return value


@${ obj.name }Api.route( '${ obj.uri }/list', methods=[ 'GET' ] )
def get${ obj.cls }List():
    recordList = db.session.query( ${ obj.cls } ).order_by( ${ obj.cls }.${ obj.table.primaryKey } ).all()
    result = ${ obj.name }sSchema.jsonify( recordList )
    logger.debug( 'get${ obj.cls }List() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/new', methods = [ 'POST' ] )
def api${ obj.cls }New():
    data    = request.json
    if data is None:
        return "Invalid request, missing ${ obj.cls }Record", 500
    logging.info( 'POST: {0}'.format( repr( data ) ) )
    if '${ obj.table.primaryKey }' in data:
        del data[ '${ obj.table.primaryKey }' ]

    record = ${ obj.cls }()
    for key, value in request.json.items():
        if key != '${ obj.table.primaryKey }' and not key.endswith( '_REL' ):
            setattr( record, key, fieldConversion( record, key, value ) )

    db.session.add( record )
    db.session.commit()
    result = ${ obj.name }Schema.jsonify( record )
    logger.debug( 'get${obj.cls}New() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/get', methods = [ 'GET' ] )
def api${ obj.cls }Get():
    data    = request.json
    if data is None:
        return "Invalid request, missing ${ obj.cls }Record", 500

    logging.info( 'GET: {0}'.format( repr( data ) ) )
    record = ${ obj.cls }.query.get( int( data[ '${ obj.table.primaryKey }' ] ) )
    result = ${ obj.name }Schema.jsonify( record )
    logger.debug( 'get${ obj.cls }Get() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/get/<int:id>', methods = [ 'GET' ] )
def api${ obj.cls }GetId( id ):
    logging.info( 'GET: {0}'.format( id ) )
    record = ${ obj.cls }.query.get( int( id ) )
    result = ${ obj.name }Schema.jsonify( record )
    logger.debug( 'get${ obj.cls }Get() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/<int:id>', methods = [ 'DELETE' ] )
def api${ obj.cls }Delete( id ):
    logging.info( 'DELETE: {0}'.format( id ) )
    record = ${ obj.cls }.query.get( int( id ) )
    db.session.delete( record )
    db.session.commit()
    result = ${ obj.name }Schema.jsonify( record )
    logger.debug( 'get${ obj.cls }Delete() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/put', methods=[ 'POST' ] )
def api${ obj.cls }Put():
    data    = request.json
    if data is None:
        return "Invalid request, missing ${ obj.cls }Record", 500
    logging.info( 'PUT: {0}'.format( repr( data ) ) )
    record = ${obj.cls}.query.get( data[ '${ obj.table.primaryKey }' ] )
    for key, value in data.items():
        if key != '${ obj.table.primaryKey }' and not key.endswith( '_REL' ):
            setattr( record, key, fieldConversion( record, key, value ) )

    db.session.commit()
    result = ${ obj.name }Schema.jsonify( record )
    logger.debug( 'get${ obj.cls }Put() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/update', methods=[ 'POST' ] )
def api${ obj.cls }Patch():
    data    = request.json
    logging.info( 'PATCH: {0}'.format( repr( data ) ) )
    record = ${ obj.cls }.query.get( data[ '${ obj.table.primaryKey }' ] )
    for key, value in data.items():
        if key != '${ obj.table.primaryKey }' and not key.endswith( '_REL' ):
            setattr( record, key, fieldConversion( record, key, value ) )

    db.session.commit()
    result = ${ obj.name }Schema.jsonify( record )
    logger.debug( 'get${ obj.cls }Patch() => {0}'.format( result ) )
    return result


@${ obj.name }Api.route( '${ obj.uri }/select', methods=[ 'GET' ] )
def api${ obj.cls }Select():
    data    = request.json
    logging.info( 'POST: {0}'.format( repr( data ) ) )
    if data is not None:
        value = data[ 'value' ]
        label = data[ 'label' ]

    else:
        value = request.args.get( 'value', '${ obj.table.primaryKey }' )    # primary key
        label = request.args.get( 'label', '${ obj.table.columns[ 1 ].name }' )  # first field name

    result = []
    recordList = db.session.query( ${ obj.cls } ).order_by( ${ obj.cls }.${ obj.table.primaryKey } ).all()
    for record in recordList:
        result.append( { 'value': getattr( record, value ),
                         'label': getattr( record, label ) } )

    logger.debug( 'api${ obj.cls }Select => {0}'.format( result ) )

    return jsonify( result )


@${ obj.name }Api.route( '${ obj.uri }/lock', methods=[ 'POST' ] )
def api${ obj.cls }Lock():
    data    = request.json
    logging.info( 'LOCK: {0}'.format( repr( data ) ) )
    # TODO: This needs to be implemented for correct multiuser support

    return jsonify( { 'result': 'OK' } )


@${ obj.name }Api.route( '${ obj.uri }/unlock', methods=[ 'POST' ] )
def api${ obj.cls }Unlock():
    data    = request.json
    logging.info( 'UNLOCK: {0}'.format( repr( data ) ) )
    # TODO: This needs to be implemented for correct multiuser support

    return jsonify( { 'result': 'OK' } )

